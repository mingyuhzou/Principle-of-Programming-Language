# 什么是编译

机器只能理解01的机器语言，但是机器语言难以理解，因此出现了汇编语言。汇编语言中引入了助记符，相对机器语言来说好理解了很多，但是汇编语言依赖于特定的机器（与CPU架构对应），并且效率低下（简单的数学表达式需要多条命令），所以在此之上又出现了高级语言。

高级语言翻译为汇编语言或直接到机器语言的过程叫做**编译**，编译语言到机器语言的过程叫做汇编。

编译过程中编译器起到重要作用，其中预处理器接收源程序作为输入，将存储在不同文件中的源程序聚合到一起，并替换宏，然后输入给编译器和汇编器

<img src="./assets/image-20250615170631455.png" alt="image-20250615170631455" style="zoom:50%;" />

经过编译器和汇编器后得到可重定位(内存中的位置以L为基地址)的机器代码

加载器可以修改重定位地址，将修改后的指令和数据放到内存中适当的位置

链接器负责将机器代码与库文件链接再生成可执行代码。





## 编译系统的结构

以翻译英语为例

词法分析：将源代码中的字符序列分割为有意义的单元(token)，如：关键字，标识符，运算符，常量

语法分析：将token构成语法树，即合法的结构

语义分析：进一步判断予以是否合理。



编译器工作分为多个步骤：

<img src="./assets/9922d05a03ce58f0c950d9b2a27e08df.png" alt="在这里插入图片描述" style="zoom:50%;" />

其中，词法分析，语法分析，语义分析，中间代码生成只和**源语言**有关，因此被称为编译器的前端，在源代码的基础上生成中间表示；而后面的部分负责在中间表示的基础上生成目标代码，只与**目标语言有关**，称为后端或者叫综合部分。



中间表示方便编译器**优化和生成**目标代码，常用的中间表示有**三地址码**，它将每一步运算拆成最多只有三个操作数的简单指令，它是四元式的一种表现形式，四元式为(OP，arg1，arg2，result)，即（操作符，操作数1，操作数2，结果）。

例如X =a*b+c/d 的四元式序列

1. `(*, a, b, T1)`
2. `(/, c, d, T2)`
3. `(+, T1, T2, T3)`
4. `(=, T3, -, X)`





# 词法分析

词法是最小的语义单元。

词法分析：**从左往右逐行扫描源程序的字符**，识别出各个单词，确定单词的类型。将识别出的单词转换为统一的机内表示——词法单元token的形式，token: <种别码，属性值>

<img src="./assets/image-20250615174213959.png" alt="image-20250615174213959" style="zoom:67%;" />



<img src="./assets/image-20250615174232087.png" alt="image-20250615174232087" style="zoom:67%;" />



## 基本概念

字母表是一个**有穷符号集合**

字母表的乘积![image-20250616200104769](./assets/image-20250616200104769.png)，幂运算<img src="./assets/image-20250616200137182.png" alt="image-20250616200137182" style="zoom:50%;" />

字母表的正闭包等于字母表的正数次幂的并集<img src="./assets/image-20250616200351523.png" alt="image-20250616200351523" style="zoom:67%;" />

克林闭包就是在正闭包的基础上加一个空串



如果x和y是串，那么xy表示x和y的连接



## 文法的定义

文法是描述合法句子结构的一种形式。

![image-20250616200832951](./assets/image-20250616200832951.png)

其中：

+ $V_T$：终结符集合，不能再分
+ $V_N$：非终结符集合，可以再分
+ P：产生式集合，将终结符和非终结符组合成串的方法
+ S：开始符号

<img src="./assets/image-20250616201243907.png" alt="image-20250616201243907" style="zoom:67%;" />

这里的产生式可以将具有相同左部的合并到一起

<img src="./assets/image-20250616201330532.png" alt="image-20250616201330532" style="zoom:67%;" />

## 语言的定义

句型：从文法的开始符号推到，得到一个可以包含终结符也可以包含非终结符的，也可能是空串的串。

句子：从文法的开始符号推导出的不包含非终结符的串

语言：由文法G的开始符号S推导出的所有句子构成的集合称为文法G生成的语言



## 文法的分类

0型文法：又称无限制文法，产生式的左部至少包含一个非终结符

1型文法：又称上下文有关文法，在0型文法的基础上进一步要求左部的长度不能大于右部的长度，不会产生空串。

2型文法：又称上下文无关文法CFG，产生式的左部是一个非终结符	

3型文法：又称正则文法，分为右线性文法和左线性文法，都是在2型文法的基础上多了一些要求，其中右线性文法规定产生式的右部是一个终结符或者终结符和一个非终结符的；左线性文法规定产生式的右部是终结符或者非终结符和一个终结符。

<img src="./assets/image-20250616203148989.png" alt="image-20250616203148989" style="zoom:67%;" />																								



四种文法之间的关系

<img src="./assets/image-20250616203246065.png" alt="image-20250616203246065" style="zoom:67%;" />

## CFG的分析树

分析树的根节点对应文法的开始符号，内部节点表示一个产生式的应用，叶节点可以是终结符或非终结符。



给定一个句型，其分析树中每一棵子树的边缘称为该句型的一个**短语**



​					 ![image-20250616204251738](./assets/image-20250616204251738.png)

如果该子树的高度为**2**，那么边缘对应的是一个**直接短语**



如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。





## 错误检测

词法分析阶段可检测错误的类型

- 单词拼写错误，错误的浮点数，16进制数
- 非法字符：非法的字符组合

如果当前状态与当前输入符号再转换表对应项中的信息为空，则报错，调用错误处理程序



错误处理：查找已扫描字符串中最后一个对应某终态的位置(已匹配的最长字符串)，如果找到了则将其别为一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词。

反之，确定出错，采用错误恢复策略，最简单的错误恢复策略是是**恐慌模式**，从剩余的输入中不断剔除字符，直到词法分析器能在剩余字符的开头发现一个正确的字符为止。





 



# 语法分析

语法分析器：**从词法分析器输出的token序列中识别出各类短语，并构造语法分析树。**

## 正则表达式

正则表达式是一种用来描述正则语言的更紧凑的表示方法

![image-20250617201707579](./assets/image-20250617201707579.png)

## 有穷自动机

有穷自动机有三个部分组成：

- 输入带：存放输入的符号串
- 读头：从左往右逐个读取输入符号，不能修改，不能往返移动
- 有穷控制器：具有有穷个状态数，根据当前状态和当前输入符号控制转入下一状态

![image-20250617204144478](./assets/image-20250617204144478.png)



有穷自动机分为确定的有穷自动机DFA(好实现)，非确定的有穷自动机NFA(更直观)，NFA对同一种输入可以有多个后继状态，允许存在**ε**转移*。

给定正则文法可以构造出一个有穷自动机，反过来，给一个有穷自动机也可以构造一个正则文法。但是正则文法不好直接转换为DFA，需要先转换为NFA再转换为DFA。

<img src="./assets/image-20250617205649582.png" alt="image-20250617205649582" style="zoom: 50%;" />



NFA到DFA的转换

<img src="./assets/image-20250617211426078.png" alt="image-20250617211426078" style="zoom:67%;" />

![image-20200327100014382](./assets/image-20200327100014382.png)





## 自顶向下的分析

对于任何需要分析的输入串，从文法的开始符号出发，用一切可能的方法结合文法的产生式，自上而下地构造一棵就基于输入串的语法树。

但是文法的产生式存在左递归，即自己能推导出自己，因此需要消除左递归。

将A->A$\alpha$称为直接左递归，经过两步及以上推到产生的左递归称为是左递归。

消除直接左递归的方法是

![image-20250619195804577](./assets/image-20250619195804577.png)

<img src="./assets/image-20250619195858800.png" alt="image-20250619195858800" style="zoom:67%;" />

也就是将直接左递归改为右递归，注意A`可以产生空串



对于间接左递归，将表达式反带入

![image-20250619200151340](./assets/image-20250619200151340.png)



## LL(1)文法

预测分析文法，从文法的开始符号出发，每一步推导过程中根据当前句型(推导出的)的最左非终结符A和当前输入符号a就能够确定一个产生式。

LL(1)第一个L表示从左往右，第二个L表示最左推导，1表示每次推导往后看一个。



定义First为可以从X推导出的所有串首终结符构成的结合，如果能推出空串也要包含。

定义Follow(A)为非终结符A的后紧跟的终结符集，能跟在A后边的终结符a的集合，可以根据表示式计算，比如A->aEb，那么E的Follow集中就包含b，或者A->Ba，那么A的Follow集就包含B的First集。



构建过程，以终结符为列，非终结符为行

<img src="./assets/image-20250619203526675.png" alt="image-20250619203526675" style="zoom:150%;" />



分析过程使用栈，首先往栈中放入#和开始符号，然后依次处理处理。对于每个输入，弹出栈顶，寻找栈顶到该输入对应的表达式，将表达式的右部倒序加入栈中。当栈中仅剩#且输入也只有#时，分析成功。



如果当前的输入与栈顶不匹配那么就出现了错误，错误的恢复采用恐慌模式，如果栈顶是终结符则弹出，如果A-





## 预测分析法的错误处理

出现错误的两种情况

- 栈顶的终结符与输入符号不匹配
- 非终结符与输入符号在分析表中对应的信息为空





错误恢复采用恐慌模式，对于不能匹配的终结符弹出；忽略掉一些输入，直到输入出现由设计者选择的**同步词法单元**集合中的某个单元，同步词法单元一般用FOLLOW集表示。

























# 语义分析

高级语言程序中的语句大体分为**声明语句和可执行语句**

+ 收集标识符的属性信息(存放在符号表中)

  + 种属：简单变量，符合变量(数组)，过程 

  + 类型

  + 存储位置，长度

  + 值

  + 作用域

+ 语义检查
  + 未申明就是用
  + 重复申明
  + 运算不匹配









